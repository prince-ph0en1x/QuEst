### 1-qubit Tomography on Qxelerator

import os
from openql import openql as ql
import re
from qxelarator import qxelarator
import numpy as np
from collections import OrderedDict
from itertools import product as cartesian_product

NUM_TRIAL = 100	# number of trials for each tomographic rotation
NUM_QUBIT = 1 

"""
The stateprep method encapsulates the quantum algorithm which generates an unknown n-qubit quantum state from an n-qubit all-zero state
We want to estimate the density matrix of this n-qubit evolved state using State Tomography
"""
def stateprep():
    config_fn = os.path.abspath('/media/sf_QWorld/Intel/OpenQL-0.6.0/tests/test_cfg_none_simple.json')
    platform = ql.Platform('platform_none', config_fn)
    prog = ql.Program('p_name', platform, NUM_QUBIT)
    k1 = ql.Kernel('QK1',platform, NUM_QUBIT)
    #k1.ry(0,np.pi/2)		# Create Superposition
    k1.gate('h',[0])		# Create Superposition
    prog.add_kernel(k1)
    prog.compile()
    qasmVerConv()
    #showQasm()

"""
Firefighting solution as Qxelarator is not updated to run cQASM v1.0
Open Issue: https://github.com/QE-Lab/qx-simulator/issues/57
Converts OpenQL generated cQASM to old Qxelerator compatible syntax
"""
def qasmVerConv():
    file = open("test_output/p_name.qasm","r")
    fileopt = open("test_output/algo.qasm","w")
    header = True
    for line in file:
        if header:
            header = False
        else:
            x = re.sub('\[','', line)
            x = re.sub('\]','', x)
            fileopt.write(x)
    file.close()
    fileopt.close()

"""
Debug method to display the cQASM code generated by OpenQL
"""
def showQasm():
    file = open("test_output/algo.qasm","r")
    for line in file:
        print (line,end='')
    file.close()

"""
Append tomographic rotation and measure to the algorithm state.
"""
def t_prep(t_rot):
    file = open("test_output/algo.qasm","r")
    fileopt = open("test_output/tomo.qasm","w")
    for line in file:
        fileopt.write(line)
    file.close()
    fileopt.write(t_rot)
    for i in range(NUM_QUBIT):
    	fileopt.write("measure q"+str(i)+"\n")
    fileopt.close()

"""
Invokes Qxelerator and returns a measurement statistics in the Z-basis (computational)
"""   
def t_trial():

	qx = qxelarator.QX()
	qx.set('test_output/tomo.qasm')
	p = np.zeros(2**NUM_QUBIT)
	c = np.zeros(NUM_QUBIT,dtype=bool)
	for i in range(NUM_TRIAL):
	    qx.execute()
	    for i in range(NUM_QUBIT):
	        c[i] = qx.get_measurement_outcome(i)
	    idx = sum(v<<i for i, v in enumerate(c[::-1]))    
	    p[idx] += 1/NUM_TRIAL
	return p

TOMOGRAPHY_GATES = OrderedDict([('i','Identity'),
								('x','Pauli-X'),
								('y','Pauli-Y'),
								('z','Pauli-Z')])

sg0 = [[1,0],[0,1]]							# Identity
sg1 = [[0,1],[1,0]]							# Pauli-X
sg2 = [[0,complex(0,-1)],[complex(0,1),0]]	# Pauli-Y
sg3 = [[1,0],[0,-1]]						# Pauli-Z

"""
vvvvvvv  HERE BE DRAGONS vvvvvvv
"""

def t_zhist():
	t_stat = []
	for gates in cartesian_product(TOMOGRAPHY_GATES.keys(), repeat=NUM_QUBIT):
		t_rot = ""
		for qubit, gate in zip([0,1], gates):
			#print(gate+str(qubit)+" ",end="")
			if gate == 'x':
				t_rot += ('ry q'+str(qubit)+", "+str(-np.pi/2)+"\n")	# is this correct?
			elif gate == 'y':
				t_rot += ('rx q'+str(qubit)+", "+str(-np.pi/2)+"\n")	# is this correct?
			elif gate == 'z':
				t_rot += ('rx q'+str(qubit)+", "+str(0)+"\n")	# is this correct?
		t_prep(t_rot)
		t_stat.append(t_trial())
		#print()
	return t_stat

def t_getdm():
	rho = np.zeros((2**NUM_QUBIT,2**NUM_QUBIT))*complex(0,0)
	idx = 0
	for gates in cartesian_product(TOMOGRAPHY_GATES.keys(), repeat=NUM_QUBIT):
		ppm = [1]
		for pm in gates:
			if pm == 'i':
				ppm = np.kron(sg0,ppm)
			elif pm == 'x':
				ppm = np.kron(sg1,ppm)
			elif pm == 'y':
				ppm = np.kron(sg2,ppm)
			elif pm == 'z':
				ppm = np.kron(sg3,ppm)
		[e_val,e_vec]=np.linalg.eig(ppm)
		Si = 0
		evn = 0
		for ev in e_val:
			Si += hist[idx][evn]*ev  # Stokes parameter {S0 = Z0 + Z1; S1 = X0 - X1; S2 = Y0 - Y1; S3 = Z0 - Z1}
			evn += 1
		rho += Si*ppm/(2**NUM_QUBIT)
		idx += 1
	return rho

stateprep()
hist = t_zhist()
print(t_getdm())