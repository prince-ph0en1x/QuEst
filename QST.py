### 2-qubit Tomography on Qxelerator

import os
from openql import openql as ql
import re
from qxelarator import qxelarator
import numpy as np
from collections import OrderedDict
from itertools import product as cartesian_product

NUM_TRIAL = 100	# number of trials for each tomographic rotation
NUM_QUBIT = 2 

"""
The stateprep method encapsulates the quantum algorithm which generates an unknown n-qubit quantum state from an n-qubit all-zero state
We want to estimate the density matrix of this n-qubit evolved state using State Tomography
"""
def stateprep():
    config_fn = os.path.abspath('/media/sf_QWorld/Intel/OpenQL-0.6.0/tests/test_cfg_none_simple.json')
    platform = ql.Platform('platform_none', config_fn)
    prog = ql.Program('p_name', platform, NUM_QUBIT)
    k1 = ql.Kernel('QK1',platform, NUM_QUBIT)
    k1.gate("h",[0])		# Create Bell Pair
    k1.gate("cnot",[0,1])	# Create Bell Pair
    prog.add_kernel(k1)
    prog.compile()
    qasmVerConv()
    #showQasm()

"""
Firefighting solution as Qxelarator is not updated to run cQASM v1.0
Open Issue: https://github.com/QE-Lab/qx-simulator/issues/57
Converts OpenQL generated cQASM to old Qxelerator compatible syntax
"""
def qasmVerConv():
    file = open("test_output/p_name.qasm","r")
    fileopt = open("test_output/algo.qasm","w")
    header = True
    for line in file:
        if header:
            header = False
        else:
            x = re.sub('\[','', line)
            x = re.sub('\]','', x)
            fileopt.write(x)
    file.close()
    fileopt.close()

"""
Debug method to display the cQASM code generated by OpenQL
"""
def showQasm():
    file = open("test_output/algo.qasm","r")
    for line in file:
        print (line,end='')
    file.close()

"""
Append tomographic rotation and measure to the algorithm state.
"""
def t_prep(t_rot):
    file = open("test_output/algo.qasm","r")
    fileopt = open("test_output/tomo.qasm","w")
    for line in file:
        fileopt.write(line)
    file.close()
    fileopt.write(t_rot)
    for i in range(NUM_QUBIT):
    	fileopt.write("measure q"+str(i)+"\n")
    fileopt.close()

"""
Invokes Qxelerator and returns a measurement statistics in the Z-basis (computational)
"""   
def t_trial():

	qx = qxelarator.QX()
	qx.set('test_output/tomo.qasm')
	p = np.zeros(2**NUM_QUBIT)
	c = np.zeros(NUM_QUBIT,dtype=bool)
	for i in range(NUM_TRIAL):
	    qx.execute()
	    for i in range(NUM_QUBIT):
	        c[i] = qx.get_measurement_outcome(i)
	    idx = sum(v<<i for i, v in enumerate(c[::-1]))    
	    p[idx] += 1/NUM_TRIAL
	return p

stateprep()

TOMOGRAPHY_GATES = OrderedDict([('i','Identity'),
								('x','Pauli-X'),
								('y','Pauli-Y'),
								('z','Pauli-Z')])

t_stat = []
for gates in cartesian_product(TOMOGRAPHY_GATES.keys(), repeat=NUM_QUBIT):
	t_rot = ""
	for qubit, gate in zip([0,1], gates):
		if gate != 'i':
			t_rot += (gate+" q"+str(qubit)+"\n")
		t_prep(t_rot)
		t_stat.append(t_trial())

print(t_stat)

# [array([0.51, 0.  , 0.  , 0.49]), array([0.48, 0.  , 0.  , 0.52]), array([0.53, 0.  , 0.  , 0.47]), array([0.  , 0.61, 0.39, 0.  ]), array([0.47, 0.  , 0.  , 0.53]), array([0.  , 0.37, 0.63, 0.  ]), array([0.52, 0.  , 0.  , 0.48]), array([0.52, 0.  , 0.  , 0.48]), array([0. , 0.5, 0.5, 0. ]), array([0.  , 0.55, 0.45, 0.  ]), array([0.  , 0.48, 0.52, 0.  ]), array([0.52, 0.  , 0.  , 0.48]), array([0.  , 0.47, 0.53, 0.  ]), array([0.44, 0.  , 0.  , 0.56]), array([0.  , 0.43, 0.57, 0.  ]), array([0.  , 0.61, 0.39, 0.  ]), array([0.  , 0.56, 0.44, 0.  ]), array([0.  , 0.43, 0.57, 0.  ]), array([0.  , 0.54, 0.46, 0.  ]), array([0.47, 0.  , 0.  , 0.53]), array([0.  , 0.51, 0.49, 0.  ]), array([0.48, 0.  , 0.  , 0.52]), array([0.  , 0.45, 0.55, 0.  ]), array([0.  , 0.53, 0.47, 0.  ]), array([0.5, 0. , 0. , 0.5]), array([0.46, 0.  , 0.  , 0.54]), array([0.41, 0.  , 0.  , 0.59]), array([0.  , 0.45, 0.55, 0.  ]), array([0.5, 0. , 0. , 0.5]), array([0.  , 0.43, 0.57, 0.  ]), array([0.47, 0.  , 0.  , 0.53]), array([0.41, 0.  , 0.  , 0.59])]
